// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package ch.bsisa.hyperbird.model.proto

import scala.concurrent.Future


/**
usage:
val obj = scalaxb.fromXML[ch.bsisa.hyperbird.model.proto.Foo](node)
val document = scalaxb.toXML[ch.bsisa.hyperbird.model.proto.Foo](obj, "foo", ch.bsisa.hyperbird.model.proto.defaultScope)
**/
object `package` extends XMLProtocol { }

trait XMLProtocol extends scalaxb.XMLStandardTypes {
  implicit lazy val executionContext = scala.concurrent.ExecutionContext.Implicits.global

  val defaultScope = scalaxb.toScope(Some("xs") -> "http://www.w3.org/2001/XMLSchema",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")
  implicit lazy val ModelMELFINFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.MELFIN] = new DefaultModelMELFINFormat {}
  implicit lazy val ModelELFINFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.ELFIN] = new DefaultModelELFINFormat {}
  implicit lazy val ModelTYPEFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.TYPE] = new DefaultModelTYPEFormat {}
  implicit lazy val ModelMUTATIONSFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.MUTATIONS] = new DefaultModelMUTATIONSFormat {}
  implicit lazy val ModelMUTATIONFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.MUTATION] = new DefaultModelMUTATIONFormat {}
  implicit lazy val ModelGEOSELECTIONFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.GEOSELECTION] = new DefaultModelGEOSELECTIONFormat {}
  implicit lazy val ModelCENTROIDEFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.CENTROIDE] = new DefaultModelCENTROIDEFormat {}
  implicit lazy val ModelIDENTIFIANTFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.IDENTIFIANT] = new DefaultModelIDENTIFIANTFormat {}
  implicit lazy val ModelFORMEFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.FORME] = new DefaultModelFORMEFormat {}
  implicit lazy val ModelPOINTFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.POINT] = new DefaultModelPOINTFormat {}
  implicit lazy val ModelFONCTIONFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.FONCTION] = new DefaultModelFONCTIONFormat {}
  implicit lazy val ModelPASSAGEFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.PASSAGE] = new DefaultModelPASSAGEFormat {}
  implicit lazy val ModelFONCTIONTypeFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.FONCTIONType] = new DefaultModelFONCTIONTypeFormat {}
  implicit lazy val ModelGUIDEFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.GUIDE] = new DefaultModelGUIDEFormat {}
  implicit lazy val ModelPIECEFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.PIECE] = new DefaultModelPIECEFormat {}
  implicit lazy val ModelLIGNEFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.LIGNE] = new DefaultModelLIGNEFormat {}
  implicit lazy val ModelDIRECTIONFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.DIRECTION] = new DefaultModelDIRECTIONFormat {}
  implicit lazy val ModelFONCTIONType2Format: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.FONCTIONType2] = new DefaultModelFONCTIONType2Format {}
  implicit lazy val ModelZONEFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.ZONE] = new DefaultModelZONEFormat {}
  implicit lazy val ModelSYMBOLEFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.SYMBOLE] = new DefaultModelSYMBOLEFormat {}
  implicit lazy val ModelLIBELLEFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.LIBELLE] = new DefaultModelLIBELLEFormat {}
  implicit lazy val ModelCARACTERISTIQUEFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.CARACTERISTIQUE] = new DefaultModelCARACTERISTIQUEFormat {}
  implicit lazy val ModelCARTypableFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.CARTypable] = new DefaultModelCARTypableFormat {}
  implicit lazy val ModelCARTypeFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.CARType] = new DefaultModelCARTypeFormat {}
  implicit lazy val ModelCARSET_CARTypeFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.CARSET_CARType] = new DefaultModelCARSET_CARTypeFormat {}
  implicit lazy val ModelCARSETFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.CARSET] = new DefaultModelCARSETFormat {}
  implicit lazy val ModelETATFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.ETAT] = new DefaultModelETATFormat {}
  implicit lazy val ModelSTATETypeFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.STATEType] = new DefaultModelSTATETypeFormat {}
  implicit lazy val ModelCALCULTypeFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.CALCULType] = new DefaultModelCALCULTypeFormat {}
  implicit lazy val ModelNOMFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.NOM] = new DefaultModelNOMFormat {}
  implicit lazy val ModelDIMENSIONFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.DIMENSION] = new DefaultModelDIMENSIONFormat {}
  implicit lazy val ModelMATRICETypableFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.MATRICETypable] = new DefaultModelMATRICETypableFormat {}
  implicit lazy val ModelMATRICETypeFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.MATRICEType] = new DefaultModelMATRICETypeFormat {}
  implicit lazy val ModelLFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.L] = new DefaultModelLFormat {}
  implicit lazy val ModelCFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.C] = new DefaultModelCFormat {}
  implicit lazy val ModelPARTENAIREFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.PARTENAIRE] = new DefaultModelPARTENAIREFormat {}
  implicit lazy val ModelPERSONNETypeFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.PERSONNEType] = new DefaultModelPERSONNETypeFormat {}
  implicit lazy val ModelACTIVITEFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.ACTIVITE] = new DefaultModelACTIVITEFormat {}
  implicit lazy val ModelEVENEMENTFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.EVENEMENT] = new DefaultModelEVENEMENTFormat {}
  implicit lazy val ModelECHEANCEFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.ECHEANCE] = new DefaultModelECHEANCEFormat {}
  implicit lazy val ModelE_STATUTFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.E_STATUT] = new DefaultModelE_STATUTFormat {}
  implicit lazy val ModelANNEXEFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.ANNEXE] = new DefaultModelANNEXEFormat {}
  implicit lazy val ModelRENVOIFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.RENVOI] = new DefaultModelRENVOIFormat {}
  implicit lazy val ModelDIVERSFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.DIVERS] = new DefaultModelDIVERSFormat {}
  implicit lazy val ModelTYPETypeFormat: scalaxb.XMLFormat[ch.bsisa.hyperbird.model.TYPEType] = new DefaultModelTYPETypeFormat {}
  implicit lazy val ModelECHEANCEu46attributeGroupFormat: scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.ECHEANCEu46attributeGroup] = new DefaultModelECHEANCEu46attributeGroupFormat {}
  implicit lazy val ModelSTATETypeu46attributeGroupFormat: scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.STATETypeu46attributeGroup] = new DefaultModelSTATETypeu46attributeGroupFormat {}
  implicit lazy val ModelLIBELLEu46attributeGroupFormat: scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.LIBELLEu46attributeGroup] = new DefaultModelLIBELLEu46attributeGroupFormat {}
  implicit lazy val ModelLIGNEu46attributeGroupFormat: scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.LIGNEu46attributeGroup] = new DefaultModelLIGNEu46attributeGroupFormat {}
  implicit lazy val ModelGUIDEu46attributeGroupFormat: scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.GUIDEu46attributeGroup] = new DefaultModelGUIDEu46attributeGroupFormat {}
  implicit lazy val ModelPOINTu46attributeGroupFormat: scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.POINTu46attributeGroup] = new DefaultModelPOINTu46attributeGroupFormat {}
  implicit lazy val ModelMUTATIONu46attributeGroupFormat: scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.MUTATIONu46attributeGroup] = new DefaultModelMUTATIONu46attributeGroupFormat {}
  implicit lazy val ModelELFINu46attributeGroupFormat: scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.ELFINu46attributeGroup] = new DefaultModelELFINu46attributeGroupFormat {}
  implicit lazy val ModelCENTROIDEu46attributeGroupFormat: scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.CENTROIDEu46attributeGroup] = new DefaultModelCENTROIDEu46attributeGroupFormat {}
  implicit lazy val ModelPASSAGEu46attributeGroupFormat: scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.PASSAGEu46attributeGroup] = new DefaultModelPASSAGEu46attributeGroupFormat {}
  implicit lazy val ModelPIECEu46attributeGroupFormat: scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.PIECEu46attributeGroup] = new DefaultModelPIECEu46attributeGroupFormat {}
  implicit lazy val ModelSYMBOLEu46attributeGroupFormat: scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.SYMBOLEu46attributeGroup] = new DefaultModelSYMBOLEu46attributeGroupFormat {}
  implicit lazy val ModelCARTypeu46attributeGroupFormat: scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.CARTypeu46attributeGroup] = new DefaultModelCARTypeu46attributeGroupFormat {}
  implicit lazy val ModelPERSONNETypeu46attributeGroupFormat: scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.PERSONNETypeu46attributeGroup] = new DefaultModelPERSONNETypeu46attributeGroupFormat {}

  trait DefaultModelMELFINFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.MELFIN] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.MELFIN] =
      phrase(safeRep(scalaxb.ElemName(None, "ELFIN")) ^^
      { case p1 =>
      ch.bsisa.hyperbird.model.MELFIN(p1 map { scalaxb.fromXML[ch.bsisa.hyperbird.model.ELFIN](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.MELFIN, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.ELFIN flatMap { scalaxb.toXML[ch.bsisa.hyperbird.model.ELFIN](_, None, Some("ELFIN"), __scope, false) })

  }

  trait DefaultModelELFINFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.ELFIN] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.ELFIN] =
      phrase(opt(scalaxb.ElemName(None, "MUTATIONS")) ~ 
      opt(scalaxb.ElemName(None, "GEOSELECTION")) ~ 
      opt(scalaxb.ElemName(None, "IDENTIFIANT")) ~ 
      opt(scalaxb.ElemName(None, "CARACTERISTIQUE")) ~ 
      opt(scalaxb.ElemName(None, "PARTENAIRE")) ~ 
      opt(scalaxb.ElemName(None, "ACTIVITE")) ~ 
      opt(scalaxb.ElemName(None, "FORME")) ~ 
      opt(scalaxb.ElemName(None, "ANNEXE")) ~ 
      opt(scalaxb.ElemName(None, "DIVERS")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 =>
      ch.bsisa.hyperbird.model.ELFIN(p1.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.MUTATIONS](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.GEOSELECTION](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.IDENTIFIANT](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.CARACTERISTIQUE](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.PARTENAIRE](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.ACTIVITE](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.FORME](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.ANNEXE](_, scalaxb.ElemName(node) :: stack) },
        p9.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.DIVERS](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@Id"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@ID_G"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@CLASSE"), scalaxb.ElemName(node) :: stack),
        (node \ "@GROUPE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@TYPE").headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.TYPE](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@NATURE"), scalaxb.ElemName(node) :: stack),
        (node \ "@SOURCE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.ELFIN, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "Id", __obj.Id.toString, attr)
      attr = scala.xml.Attribute(null, "ID_G", __obj.ID_G.toString, attr)
      attr = scala.xml.Attribute(null, "CLASSE", __obj.CLASSE.toString, attr)
      __obj.GROUPE foreach { x => attr = scala.xml.Attribute(null, "GROUPE", x.toString, attr) }
      __obj.TYPE foreach { x => attr = scala.xml.Attribute(null, "TYPE", x.toString, attr) }
      attr = scala.xml.Attribute(null, "NATURE", __obj.NATURE.toString, attr)
      __obj.SOURCE foreach { x => attr = scala.xml.Attribute(null, "SOURCE", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.ELFIN, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.MUTATIONS map { scalaxb.toXML[ch.bsisa.hyperbird.model.MUTATIONS](_, None, Some("MUTATIONS"), __scope, false) } getOrElse {Nil},
        __obj.GEOSELECTION map { scalaxb.toXML[ch.bsisa.hyperbird.model.GEOSELECTION](_, None, Some("GEOSELECTION"), __scope, false) } getOrElse {Nil},
        __obj.IDENTIFIANT map { scalaxb.toXML[ch.bsisa.hyperbird.model.IDENTIFIANT](_, None, Some("IDENTIFIANT"), __scope, false) } getOrElse {Nil},
        __obj.CARACTERISTIQUE map { scalaxb.toXML[ch.bsisa.hyperbird.model.CARACTERISTIQUE](_, None, Some("CARACTERISTIQUE"), __scope, false) } getOrElse {Nil},
        __obj.PARTENAIRE map { scalaxb.toXML[ch.bsisa.hyperbird.model.PARTENAIRE](_, None, Some("PARTENAIRE"), __scope, false) } getOrElse {Nil},
        __obj.ACTIVITE map { scalaxb.toXML[ch.bsisa.hyperbird.model.ACTIVITE](_, None, Some("ACTIVITE"), __scope, false) } getOrElse {Nil},
        __obj.FORME map { scalaxb.toXML[ch.bsisa.hyperbird.model.FORME](_, None, Some("FORME"), __scope, false) } getOrElse {Nil},
        __obj.ANNEXE map { scalaxb.toXML[ch.bsisa.hyperbird.model.ANNEXE](_, None, Some("ANNEXE"), __scope, false) } getOrElse {Nil},
        __obj.DIVERS map { scalaxb.toXML[ch.bsisa.hyperbird.model.DIVERS](_, None, Some("DIVERS"), __scope, false) } getOrElse {Nil})

  }

  def buildModelTYPEFormat = new DefaultModelTYPEFormat {}
  trait DefaultModelTYPEFormat extends scalaxb.XMLFormat[ch.bsisa.hyperbird.model.TYPE] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.TYPE] = seq match {
      case elem: scala.xml.Elem => Right(ch.bsisa.hyperbird.model.TYPE.fromString(elem.text, elem.scope))
      case _ => Right(ch.bsisa.hyperbird.model.TYPE.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: ch.bsisa.hyperbird.model.TYPE, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultModelMUTATIONSFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.MUTATIONS] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.MUTATIONS] =
      phrase(safeRep(scalaxb.ElemName(None, "MUTATION")) ^^
      { case p1 =>
      ch.bsisa.hyperbird.model.MUTATIONS(p1 map { scalaxb.fromXML[ch.bsisa.hyperbird.model.MUTATION](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.MUTATIONS, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.MUTATION flatMap { scalaxb.toXML[ch.bsisa.hyperbird.model.MUTATION](_, None, Some("MUTATION"), __scope, false) })

  }

  trait DefaultModelMUTATIONFormat extends scalaxb.XMLFormat[ch.bsisa.hyperbird.model.MUTATION] with scalaxb.CanWriteChildNodes[ch.bsisa.hyperbird.model.MUTATION] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.MUTATION] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.MUTATION(scalaxb.fromXML[String]((node \ "@DATE"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@ROLE"), scalaxb.ElemName(node) :: stack),
        (node \ "@MOT_DE_PASSE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@UTILISATEUR").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.MUTATION, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "DATE", __obj.DATE.toString, attr)
      attr = scala.xml.Attribute(null, "ROLE", __obj.ROLE.toString, attr)
      __obj.MOT_DE_PASSE foreach { x => attr = scala.xml.Attribute(null, "MOT_DE_PASSE", x.toString, attr) }
      __obj.UTILISATEUR foreach { x => attr = scala.xml.Attribute(null, "UTILISATEUR", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.MUTATION, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultModelGEOSELECTIONFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.GEOSELECTION] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.GEOSELECTION] =
      phrase(safeRep(scalaxb.ElemName(None, "CENTROIDE")) ^^
      { case p1 =>
      ch.bsisa.hyperbird.model.GEOSELECTION(p1 map { scalaxb.fromXML[ch.bsisa.hyperbird.model.CENTROIDE](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.GEOSELECTION, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.CENTROIDE flatMap { scalaxb.toXML[ch.bsisa.hyperbird.model.CENTROIDE](_, None, Some("CENTROIDE"), __scope, false) })

  }

  trait DefaultModelCENTROIDEFormat extends scalaxb.XMLFormat[ch.bsisa.hyperbird.model.CENTROIDE] with scalaxb.CanWriteChildNodes[ch.bsisa.hyperbird.model.CENTROIDE] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.CENTROIDE] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.CENTROIDE(scalaxb.fromXML[ch.bsisa.hyperbird.model.TYPEType]((node \ "@TYPE"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Double]((node \ "@XM"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Double]((node \ "@YM"), scalaxb.ElemName(node) :: stack),
        (node \ "@ZM").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Double]((node \ "@RM"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.CENTROIDE, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "TYPE", __obj.TYPE.toString, attr)
      attr = scala.xml.Attribute(null, "XM", __obj.XM.toString, attr)
      attr = scala.xml.Attribute(null, "YM", __obj.YM.toString, attr)
      __obj.ZM foreach { x => attr = scala.xml.Attribute(null, "ZM", x.toString, attr) }
      attr = scala.xml.Attribute(null, "RM", __obj.RM.toString, attr)
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.CENTROIDE, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultModelIDENTIFIANTFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.IDENTIFIANT] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.IDENTIFIANT] =
      phrase(opt(scalaxb.ElemName(None, "AUT")) ~ 
      opt(scalaxb.ElemName(None, "GER")) ~ 
      opt(scalaxb.ElemName(None, "RES")) ~ 
      opt(scalaxb.ElemName(None, "NOM")) ~ 
      opt(scalaxb.ElemName(None, "ALIAS")) ~ 
      opt(scalaxb.ElemName(None, "ORIGINE")) ~ 
      opt(scalaxb.ElemName(None, "OBJECTIF")) ~ 
      opt(scalaxb.ElemName(None, "QUALITE")) ~ 
      opt(scalaxb.ElemName(None, "COMPTE")) ~ 
      opt(scalaxb.ElemName(None, "DE")) ~ 
      opt(scalaxb.ElemName(None, "A")) ~ 
      opt(scalaxb.ElemName(None, "PAR")) ~ 
      opt(scalaxb.ElemName(None, "VALEUR_A_NEUF")) ~ 
      opt(scalaxb.ElemName(None, "VALEUR")) ~ 
      safeRep(scalaxb.ElemName(None, "MOTCLE")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 ~ p15 =>
      ch.bsisa.hyperbird.model.IDENTIFIANT(p1.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p9.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p10.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p11.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p12.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p13.headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) },
        p14.headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) },
        p15 map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.IDENTIFIANT, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.AUT map { scalaxb.toXML[String](_, None, Some("AUT"), __scope, false) } getOrElse {Nil},
        __obj.GER map { scalaxb.toXML[String](_, None, Some("GER"), __scope, false) } getOrElse {Nil},
        __obj.RES map { scalaxb.toXML[String](_, None, Some("RES"), __scope, false) } getOrElse {Nil},
        __obj.NOM map { scalaxb.toXML[String](_, None, Some("NOM"), __scope, false) } getOrElse {Nil},
        __obj.ALIAS map { scalaxb.toXML[String](_, None, Some("ALIAS"), __scope, false) } getOrElse {Nil},
        __obj.ORIGINE map { scalaxb.toXML[String](_, None, Some("ORIGINE"), __scope, false) } getOrElse {Nil},
        __obj.OBJECTIF map { scalaxb.toXML[String](_, None, Some("OBJECTIF"), __scope, false) } getOrElse {Nil},
        __obj.QUALITE map { scalaxb.toXML[String](_, None, Some("QUALITE"), __scope, false) } getOrElse {Nil},
        __obj.COMPTE map { scalaxb.toXML[String](_, None, Some("COMPTE"), __scope, false) } getOrElse {Nil},
        __obj.DE map { scalaxb.toXML[String](_, None, Some("DE"), __scope, false) } getOrElse {Nil},
        __obj.A map { scalaxb.toXML[String](_, None, Some("A"), __scope, false) } getOrElse {Nil},
        __obj.PAR map { scalaxb.toXML[String](_, None, Some("PAR"), __scope, false) } getOrElse {Nil},
        __obj.VALEUR_A_NEUF map { scalaxb.toXML[Double](_, None, Some("VALEUR_A_NEUF"), __scope, false) } getOrElse {Nil},
        __obj.VALEUR map { scalaxb.toXML[Double](_, None, Some("VALEUR"), __scope, false) } getOrElse {Nil},
        __obj.MOTCLE flatMap { scalaxb.toXML[String](_, None, Some("MOTCLE"), __scope, false) })

  }

  trait DefaultModelFORMEFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.FORME] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.FORME] =
      phrase(safeRep(scalaxb.ElemName(None, "POINT")) ~ 
      safeRep(scalaxb.ElemName(None, "LIGNE")) ~ 
      safeRep(scalaxb.ElemName(None, "ZONE")) ~ 
      safeRep(scalaxb.ElemName(None, "SYMBOLE")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ch.bsisa.hyperbird.model.FORME(p1 map { scalaxb.fromXML[ch.bsisa.hyperbird.model.POINT](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[ch.bsisa.hyperbird.model.LIGNE](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[ch.bsisa.hyperbird.model.ZONE](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[ch.bsisa.hyperbird.model.SYMBOLE](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.FORME, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.POINT flatMap { scalaxb.toXML[ch.bsisa.hyperbird.model.POINT](_, None, Some("POINT"), __scope, false) },
        __obj.LIGNE flatMap { scalaxb.toXML[ch.bsisa.hyperbird.model.LIGNE](_, None, Some("LIGNE"), __scope, false) },
        __obj.ZONE flatMap { scalaxb.toXML[ch.bsisa.hyperbird.model.ZONE](_, None, Some("ZONE"), __scope, false) },
        __obj.SYMBOLE flatMap { scalaxb.toXML[ch.bsisa.hyperbird.model.SYMBOLE](_, None, Some("SYMBOLE"), __scope, false) })

  }

  trait DefaultModelPOINTFormat extends scalaxb.XMLFormat[ch.bsisa.hyperbird.model.POINT] with scalaxb.CanWriteChildNodes[ch.bsisa.hyperbird.model.POINT] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.POINT] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.POINT(scalaxb.fromXML[BigInt]((node \ "@POS"), scalaxb.ElemName(node) :: stack),
        (node \ "@X").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@Y").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@Z").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@XG").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@YG").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@ZG").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@KSI").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ANGLE").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ALPHA").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[String](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@XS").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@YS").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@ZS").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@KSIS").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ANGLES").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ALPHAS").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[String](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@Id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@ID_G").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[ch.bsisa.hyperbird.model.FONCTION]((node \ "@FONCTION"), scalaxb.ElemName(node) :: stack),
        (node \ "@CLASSE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@GROUPE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.POINT, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "POS", __obj.POS.toString, attr)
      __obj.X foreach { x => attr = scala.xml.Attribute(null, "X", x.toString, attr) }
      __obj.Y foreach { x => attr = scala.xml.Attribute(null, "Y", x.toString, attr) }
      if (__obj.Z.toString != "0") attr = scala.xml.Attribute(null, "Z", __obj.Z.toString, attr)
      __obj.XG foreach { x => attr = scala.xml.Attribute(null, "XG", x.toString, attr) }
      __obj.YG foreach { x => attr = scala.xml.Attribute(null, "YG", x.toString, attr) }
      __obj.ZG foreach { x => attr = scala.xml.Attribute(null, "ZG", x.toString, attr) }
      if (__obj.KSI.toString != "0") attr = scala.xml.Attribute(null, "KSI", __obj.KSI.toString, attr)
      if (__obj.ANGLE.toString != "0") attr = scala.xml.Attribute(null, "ANGLE", __obj.ANGLE.toString, attr)
      if (__obj.ALPHA.toString != "0") attr = scala.xml.Attribute(null, "ALPHA", __obj.ALPHA.toString, attr)
      __obj.XS foreach { x => attr = scala.xml.Attribute(null, "XS", x.toString, attr) }
      __obj.YS foreach { x => attr = scala.xml.Attribute(null, "YS", x.toString, attr) }
      if (__obj.ZS.toString != "0") attr = scala.xml.Attribute(null, "ZS", __obj.ZS.toString, attr)
      if (__obj.KSIS.toString != "0") attr = scala.xml.Attribute(null, "KSIS", __obj.KSIS.toString, attr)
      if (__obj.ANGLES.toString != "0") attr = scala.xml.Attribute(null, "ANGLES", __obj.ANGLES.toString, attr)
      if (__obj.ALPHAS.toString != "0") attr = scala.xml.Attribute(null, "ALPHAS", __obj.ALPHAS.toString, attr)
      __obj.Id foreach { x => attr = scala.xml.Attribute(null, "Id", x.toString, attr) }
      __obj.ID_G foreach { x => attr = scala.xml.Attribute(null, "ID_G", x.toString, attr) }
      attr = scala.xml.Attribute(null, "FONCTION", __obj.FONCTION.toString, attr)
      __obj.CLASSE foreach { x => attr = scala.xml.Attribute(null, "CLASSE", x.toString, attr) }
      __obj.GROUPE foreach { x => attr = scala.xml.Attribute(null, "GROUPE", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.POINT, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  def buildModelFONCTIONFormat = new DefaultModelFONCTIONFormat {}
  trait DefaultModelFONCTIONFormat extends scalaxb.XMLFormat[ch.bsisa.hyperbird.model.FONCTION] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.FONCTION] = seq match {
      case elem: scala.xml.Elem => Right(ch.bsisa.hyperbird.model.FONCTION.fromString(elem.text, elem.scope))
      case _ => Right(ch.bsisa.hyperbird.model.FONCTION.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: ch.bsisa.hyperbird.model.FONCTION, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultModelPASSAGEFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.PASSAGE] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.PASSAGE] =
      phrase(opt(scalaxb.ElemName(None, "PIECE")) ^^
      { case p1 =>
      ch.bsisa.hyperbird.model.PASSAGE(p1.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.PIECE](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@POS").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@KSI").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ANGLE").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ALPHA").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@KSIS").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ANGLES").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ALPHAS").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@Id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@ID_G").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[ch.bsisa.hyperbird.model.FONCTIONType]((node \ "@FONCTION"), scalaxb.ElemName(node) :: stack),
        (node \ "@CLASSE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@GROUPE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@REMARQUE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.PASSAGE, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.POS foreach { x => attr = scala.xml.Attribute(null, "POS", x.toString, attr) }
      if (__obj.KSI.toString != "0") attr = scala.xml.Attribute(null, "KSI", __obj.KSI.toString, attr)
      if (__obj.ANGLE.toString != "0") attr = scala.xml.Attribute(null, "ANGLE", __obj.ANGLE.toString, attr)
      __obj.ALPHA foreach { x => attr = scala.xml.Attribute(null, "ALPHA", x.toString, attr) }
      if (__obj.KSIS.toString != "0") attr = scala.xml.Attribute(null, "KSIS", __obj.KSIS.toString, attr)
      if (__obj.ANGLES.toString != "0") attr = scala.xml.Attribute(null, "ANGLES", __obj.ANGLES.toString, attr)
      __obj.ALPHAS foreach { x => attr = scala.xml.Attribute(null, "ALPHAS", x.toString, attr) }
      __obj.Id foreach { x => attr = scala.xml.Attribute(null, "Id", x.toString, attr) }
      __obj.ID_G foreach { x => attr = scala.xml.Attribute(null, "ID_G", x.toString, attr) }
      attr = scala.xml.Attribute(null, "FONCTION", __obj.FONCTION.toString, attr)
      __obj.CLASSE foreach { x => attr = scala.xml.Attribute(null, "CLASSE", x.toString, attr) }
      __obj.GROUPE foreach { x => attr = scala.xml.Attribute(null, "GROUPE", x.toString, attr) }
      __obj.REMARQUE foreach { x => attr = scala.xml.Attribute(null, "REMARQUE", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.PASSAGE, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.PIECE map { scalaxb.toXML[ch.bsisa.hyperbird.model.PIECE](_, None, Some("PIECE"), __scope, false) } getOrElse {Nil})

  }

  def buildModelFONCTIONTypeFormat = new DefaultModelFONCTIONTypeFormat {}
  trait DefaultModelFONCTIONTypeFormat extends scalaxb.XMLFormat[ch.bsisa.hyperbird.model.FONCTIONType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.FONCTIONType] = seq match {
      case elem: scala.xml.Elem => Right(ch.bsisa.hyperbird.model.FONCTIONType.fromString(elem.text, elem.scope))
      case _ => Right(ch.bsisa.hyperbird.model.FONCTIONType.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: ch.bsisa.hyperbird.model.FONCTIONType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultModelGUIDEFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.GUIDE] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.GUIDE] =
      phrase(opt(scalaxb.ElemName(None, "PIECE")) ^^
      { case p1 =>
      ch.bsisa.hyperbird.model.GUIDE(p1.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.PIECE](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[BigInt]((node \ "@POS"), scalaxb.ElemName(node) :: stack),
        (node \ "@KSI").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@KSI2").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ETA").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ALPHA").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@KSIS").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@KSIS2").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ETAS").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ALPHAS").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@Id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@ID_G").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@CLASSE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@REMARQUE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.GUIDE, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "POS", __obj.POS.toString, attr)
      if (__obj.KSI.toString != "0") attr = scala.xml.Attribute(null, "KSI", __obj.KSI.toString, attr)
      if (__obj.KSI2.toString != "0") attr = scala.xml.Attribute(null, "KSI2", __obj.KSI2.toString, attr)
      if (__obj.ETA.toString != "0") attr = scala.xml.Attribute(null, "ETA", __obj.ETA.toString, attr)
      __obj.ALPHA foreach { x => attr = scala.xml.Attribute(null, "ALPHA", x.toString, attr) }
      if (__obj.KSIS.toString != "0") attr = scala.xml.Attribute(null, "KSIS", __obj.KSIS.toString, attr)
      if (__obj.KSIS2.toString != "0") attr = scala.xml.Attribute(null, "KSIS2", __obj.KSIS2.toString, attr)
      if (__obj.ETAS.toString != "0") attr = scala.xml.Attribute(null, "ETAS", __obj.ETAS.toString, attr)
      __obj.ALPHAS foreach { x => attr = scala.xml.Attribute(null, "ALPHAS", x.toString, attr) }
      __obj.Id foreach { x => attr = scala.xml.Attribute(null, "Id", x.toString, attr) }
      __obj.ID_G foreach { x => attr = scala.xml.Attribute(null, "ID_G", x.toString, attr) }
      __obj.CLASSE foreach { x => attr = scala.xml.Attribute(null, "CLASSE", x.toString, attr) }
      __obj.REMARQUE foreach { x => attr = scala.xml.Attribute(null, "REMARQUE", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.GUIDE, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.PIECE map { scalaxb.toXML[ch.bsisa.hyperbird.model.PIECE](_, None, Some("PIECE"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultModelPIECEFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.PIECE] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.PIECE] =
      phrase(opt(scalaxb.ElemName(None, "CAR1")) ~ 
      opt(scalaxb.ElemName(None, "CAR2")) ~ 
      opt(scalaxb.ElemName(None, "CAR3")) ^^
      { case p1 ~ p2 ~ p3 =>
      ch.bsisa.hyperbird.model.PIECE(p1.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.CARTypable](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.CARTypable](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.CARTypable](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@ALIAS"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@Id"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@ID_G"), scalaxb.ElemName(node) :: stack),
        (node \ "@SYMBOLE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Double]((node \ "@LONGUEUR_UTILE"), scalaxb.ElemName(node) :: stack),
        (node \ "@ANGLE").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0.0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ECHELLE_X").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ECHELLE_Y").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ECHELLE_Z").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.PIECE, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "ALIAS", __obj.ALIAS.toString, attr)
      attr = scala.xml.Attribute(null, "Id", __obj.Id.toString, attr)
      attr = scala.xml.Attribute(null, "ID_G", __obj.ID_G.toString, attr)
      __obj.SYMBOLE foreach { x => attr = scala.xml.Attribute(null, "SYMBOLE", x.toString, attr) }
      attr = scala.xml.Attribute(null, "LONGUEUR_UTILE", __obj.LONGUEUR_UTILE.toString, attr)
      if (__obj.ANGLE.toString != "0.0") attr = scala.xml.Attribute(null, "ANGLE", __obj.ANGLE.toString, attr)
      if (__obj.ECHELLE_X.toString != "1.0") attr = scala.xml.Attribute(null, "ECHELLE_X", __obj.ECHELLE_X.toString, attr)
      if (__obj.ECHELLE_Y.toString != "1.0") attr = scala.xml.Attribute(null, "ECHELLE_Y", __obj.ECHELLE_Y.toString, attr)
      if (__obj.ECHELLE_Z.toString != "1.0") attr = scala.xml.Attribute(null, "ECHELLE_Z", __obj.ECHELLE_Z.toString, attr)
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.PIECE, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.CAR1 map { scalaxb.toXML[ch.bsisa.hyperbird.model.CARTypable](_, None, Some("CAR1"), __scope, false) } getOrElse {Nil},
        __obj.CAR2 map { scalaxb.toXML[ch.bsisa.hyperbird.model.CARTypable](_, None, Some("CAR2"), __scope, false) } getOrElse {Nil},
        __obj.CAR3 map { scalaxb.toXML[ch.bsisa.hyperbird.model.CARTypable](_, None, Some("CAR3"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultModelLIGNEFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.LIGNE] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.LIGNE] =
      phrase(safeRep(scalaxb.ElemName(None, "PASSAGE")) ~ 
      safeRep(scalaxb.ElemName(None, "GUIDE")) ^^
      { case p1 ~ p2 =>
      ch.bsisa.hyperbird.model.LIGNE(p1 map { scalaxb.fromXML[ch.bsisa.hyperbird.model.PASSAGE](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[ch.bsisa.hyperbird.model.GUIDE](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[BigInt]((node \ "@POS"), scalaxb.ElemName(node) :: stack),
        (node \ "@DIRECTION").headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.DIRECTION](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[ch.bsisa.hyperbird.model.DIRECTION](scala.xml.Text("AVAL"), scalaxb.ElemName(node) :: stack) },
        (node \ "@Id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@ID_G").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@CLASSE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@FONCTION").headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.FONCTIONType2](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@REMARQUE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.LIGNE, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "POS", __obj.POS.toString, attr)
      if (__obj.DIRECTION.toString != "AVAL") attr = scala.xml.Attribute(null, "DIRECTION", __obj.DIRECTION.toString, attr)
      __obj.Id foreach { x => attr = scala.xml.Attribute(null, "Id", x.toString, attr) }
      __obj.ID_G foreach { x => attr = scala.xml.Attribute(null, "ID_G", x.toString, attr) }
      __obj.CLASSE foreach { x => attr = scala.xml.Attribute(null, "CLASSE", x.toString, attr) }
      __obj.FONCTION foreach { x => attr = scala.xml.Attribute(null, "FONCTION", x.toString, attr) }
      __obj.REMARQUE foreach { x => attr = scala.xml.Attribute(null, "REMARQUE", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.LIGNE, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.PASSAGE flatMap { scalaxb.toXML[ch.bsisa.hyperbird.model.PASSAGE](_, None, Some("PASSAGE"), __scope, false) },
        __obj.GUIDE flatMap { scalaxb.toXML[ch.bsisa.hyperbird.model.GUIDE](_, None, Some("GUIDE"), __scope, false) })

  }

  def buildModelDIRECTIONFormat = new DefaultModelDIRECTIONFormat {}
  trait DefaultModelDIRECTIONFormat extends scalaxb.XMLFormat[ch.bsisa.hyperbird.model.DIRECTION] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.DIRECTION] = seq match {
      case elem: scala.xml.Elem => Right(ch.bsisa.hyperbird.model.DIRECTION.fromString(elem.text, elem.scope))
      case _ => Right(ch.bsisa.hyperbird.model.DIRECTION.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: ch.bsisa.hyperbird.model.DIRECTION, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildModelFONCTIONType2Format = new DefaultModelFONCTIONType2Format {}
  trait DefaultModelFONCTIONType2Format extends scalaxb.XMLFormat[ch.bsisa.hyperbird.model.FONCTIONType2] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.FONCTIONType2] = seq match {
      case elem: scala.xml.Elem => Right(ch.bsisa.hyperbird.model.FONCTIONType2.fromString(elem.text, elem.scope))
      case _ => Right(ch.bsisa.hyperbird.model.FONCTIONType2.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: ch.bsisa.hyperbird.model.FONCTIONType2, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultModelZONEFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.ZONE] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.ZONE] =
      phrase(safeRep(scalaxb.ElemName(None, "LIGNE")) ^^
      { case p1 =>
      ch.bsisa.hyperbird.model.ZONE(p1 map { scalaxb.fromXML[ch.bsisa.hyperbird.model.LIGNE](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@POS").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@Id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@ID_G").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@CLASSE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@REMARQUE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.ZONE, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.POS foreach { x => attr = scala.xml.Attribute(null, "POS", x.toString, attr) }
      __obj.Id foreach { x => attr = scala.xml.Attribute(null, "Id", x.toString, attr) }
      __obj.ID_G foreach { x => attr = scala.xml.Attribute(null, "ID_G", x.toString, attr) }
      __obj.CLASSE foreach { x => attr = scala.xml.Attribute(null, "CLASSE", x.toString, attr) }
      __obj.REMARQUE foreach { x => attr = scala.xml.Attribute(null, "REMARQUE", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.ZONE, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.LIGNE flatMap { scalaxb.toXML[ch.bsisa.hyperbird.model.LIGNE](_, None, Some("LIGNE"), __scope, false) })

  }

  trait DefaultModelSYMBOLEFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.SYMBOLE] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.SYMBOLE] =
      phrase(safeRep(scalaxb.ElemName(None, "LIBELLE")) ^^
      { case p1 =>
      ch.bsisa.hyperbird.model.SYMBOLE(p1 map { scalaxb.fromXML[ch.bsisa.hyperbird.model.LIBELLE](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[BigInt]((node \ "@POS"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@NOM"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@CONTEXTE"), scalaxb.ElemName(node) :: stack),
        (node \ "@X").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0.0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@Y").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0.0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ALPHA").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@ANGLE").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0.0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ECHELLE_X").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ECHELLE_Y").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ECHELLE_Z").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@REMARQUE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.SYMBOLE, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "POS", __obj.POS.toString, attr)
      attr = scala.xml.Attribute(null, "NOM", __obj.NOM.toString, attr)
      attr = scala.xml.Attribute(null, "CONTEXTE", __obj.CONTEXTE.toString, attr)
      if (__obj.X.toString != "0.0") attr = scala.xml.Attribute(null, "X", __obj.X.toString, attr)
      if (__obj.Y.toString != "0.0") attr = scala.xml.Attribute(null, "Y", __obj.Y.toString, attr)
      __obj.ALPHA foreach { x => attr = scala.xml.Attribute(null, "ALPHA", x.toString, attr) }
      if (__obj.ANGLE.toString != "0.0") attr = scala.xml.Attribute(null, "ANGLE", __obj.ANGLE.toString, attr)
      if (__obj.ECHELLE_X.toString != "1.0") attr = scala.xml.Attribute(null, "ECHELLE_X", __obj.ECHELLE_X.toString, attr)
      if (__obj.ECHELLE_Y.toString != "1.0") attr = scala.xml.Attribute(null, "ECHELLE_Y", __obj.ECHELLE_Y.toString, attr)
      if (__obj.ECHELLE_Z.toString != "1.0") attr = scala.xml.Attribute(null, "ECHELLE_Z", __obj.ECHELLE_Z.toString, attr)
      __obj.REMARQUE foreach { x => attr = scala.xml.Attribute(null, "REMARQUE", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.SYMBOLE, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.LIBELLE flatMap { scalaxb.toXML[ch.bsisa.hyperbird.model.LIBELLE](_, None, Some("LIBELLE"), __scope, false) })

  }

  trait DefaultModelLIBELLEFormat extends scalaxb.XMLFormat[ch.bsisa.hyperbird.model.LIBELLE] with scalaxb.CanWriteChildNodes[ch.bsisa.hyperbird.model.LIBELLE] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.LIBELLE] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.LIBELLE((node \ "@POS").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@TEXTE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@X").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0.0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@Y").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0.0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ALPHA").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@TAILLE").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@ANGLE").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0.0"), scalaxb.ElemName(node) :: stack) },
        (node \ "@REMARQUE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.LIBELLE, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.POS foreach { x => attr = scala.xml.Attribute(null, "POS", x.toString, attr) }
      __obj.TEXTE foreach { x => attr = scala.xml.Attribute(null, "TEXTE", x.toString, attr) }
      if (__obj.X.toString != "0.0") attr = scala.xml.Attribute(null, "X", __obj.X.toString, attr)
      if (__obj.Y.toString != "0.0") attr = scala.xml.Attribute(null, "Y", __obj.Y.toString, attr)
      __obj.ALPHA foreach { x => attr = scala.xml.Attribute(null, "ALPHA", x.toString, attr) }
      if (__obj.TAILLE.toString != "1.0") attr = scala.xml.Attribute(null, "TAILLE", __obj.TAILLE.toString, attr)
      if (__obj.ANGLE.toString != "0.0") attr = scala.xml.Attribute(null, "ANGLE", __obj.ANGLE.toString, attr)
      __obj.REMARQUE foreach { x => attr = scala.xml.Attribute(null, "REMARQUE", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.LIBELLE, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultModelCARACTERISTIQUEFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.CARACTERISTIQUE] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.CARACTERISTIQUE] =
      phrase(opt(scalaxb.ElemName(None, "CAR1")) ~ 
      opt(scalaxb.ElemName(None, "CAR2")) ~ 
      opt(scalaxb.ElemName(None, "CAR3")) ~ 
      opt(scalaxb.ElemName(None, "CAR4")) ~ 
      opt(scalaxb.ElemName(None, "CAR5")) ~ 
      opt(scalaxb.ElemName(None, "CAR6")) ~ 
      opt(scalaxb.ElemName(None, "CARSET")) ~ 
      opt(scalaxb.ElemName(None, "ETAT")) ~ 
      opt(scalaxb.ElemName(None, "CALCUL")) ~ 
      opt(scalaxb.ElemName(None, "FRACTION")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 =>
      ch.bsisa.hyperbird.model.CARACTERISTIQUE(p1.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.CARTypable](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.CARTypable](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.CARTypable](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.CARTypable](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.CARTypable](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.CARTypable](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.CARSET](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.ETAT](_, scalaxb.ElemName(node) :: stack) },
        p9.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.CALCULType](_, scalaxb.ElemName(node) :: stack) },
        p10.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.MATRICETypable](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.CARACTERISTIQUE, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.CAR1 map { scalaxb.toXML[ch.bsisa.hyperbird.model.CARTypable](_, None, Some("CAR1"), __scope, false) } getOrElse {Nil},
        __obj.CAR2 map { scalaxb.toXML[ch.bsisa.hyperbird.model.CARTypable](_, None, Some("CAR2"), __scope, false) } getOrElse {Nil},
        __obj.CAR3 map { scalaxb.toXML[ch.bsisa.hyperbird.model.CARTypable](_, None, Some("CAR3"), __scope, false) } getOrElse {Nil},
        __obj.CAR4 map { scalaxb.toXML[ch.bsisa.hyperbird.model.CARTypable](_, None, Some("CAR4"), __scope, false) } getOrElse {Nil},
        __obj.CAR5 map { scalaxb.toXML[ch.bsisa.hyperbird.model.CARTypable](_, None, Some("CAR5"), __scope, false) } getOrElse {Nil},
        __obj.CAR6 map { scalaxb.toXML[ch.bsisa.hyperbird.model.CARTypable](_, None, Some("CAR6"), __scope, false) } getOrElse {Nil},
        __obj.CARSET map { scalaxb.toXML[ch.bsisa.hyperbird.model.CARSET](_, None, Some("CARSET"), __scope, false) } getOrElse {Nil},
        __obj.ETAT map { scalaxb.toXML[ch.bsisa.hyperbird.model.ETAT](_, None, Some("ETAT"), __scope, false) } getOrElse {Nil},
        __obj.CALCUL map { scalaxb.toXML[ch.bsisa.hyperbird.model.CALCULType](_, None, Some("CALCUL"), __scope, false) } getOrElse {Nil},
        __obj.FRACTION map { scalaxb.toXML[ch.bsisa.hyperbird.model.MATRICETypable](_, None, Some("FRACTION"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultModelCARTypableFormat extends scalaxb.XMLFormat[ch.bsisa.hyperbird.model.CARTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.CARTypable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (None, Some("CARSET_CARType")) => Right(scalaxb.fromXML[ch.bsisa.hyperbird.model.CARSET_CARType](node, stack))
          case _ => Right(scalaxb.fromXML[ch.bsisa.hyperbird.model.CARType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: ch.bsisa.hyperbird.model.CARTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: ch.bsisa.hyperbird.model.CARSET_CARType => scalaxb.toXML[ch.bsisa.hyperbird.model.CARSET_CARType](x, __namespace, __elementLabel, __scope, true)
      case x: ch.bsisa.hyperbird.model.CARType => scalaxb.toXML[ch.bsisa.hyperbird.model.CARType](x, __namespace, __elementLabel, __scope, false)
    }
  }

  trait DefaultModelCARTypeFormat extends scalaxb.XMLFormat[ch.bsisa.hyperbird.model.CARType] with scalaxb.CanWriteChildNodes[ch.bsisa.hyperbird.model.CARType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.CARType] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.CARType((node \ "@NOM").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@UNITE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@VALEUR").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.CARType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.NOM foreach { x => attr = scala.xml.Attribute(null, "NOM", x.toString, attr) }
      __obj.UNITE foreach { x => attr = scala.xml.Attribute(null, "UNITE", x.toString, attr) }
      __obj.VALEUR foreach { x => attr = scala.xml.Attribute(null, "VALEUR", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.CARType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultModelCARSET_CARTypeFormat extends scalaxb.XMLFormat[ch.bsisa.hyperbird.model.CARSET_CARType] with scalaxb.CanWriteChildNodes[ch.bsisa.hyperbird.model.CARSET_CARType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.CARSET_CARType] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.CARSET_CARType((node \ "@NOM").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@UNITE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@VALEUR").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[BigInt]((node \ "@POS"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.CARSET_CARType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.NOM foreach { x => attr = scala.xml.Attribute(null, "NOM", x.toString, attr) }
      __obj.UNITE foreach { x => attr = scala.xml.Attribute(null, "UNITE", x.toString, attr) }
      __obj.VALEUR foreach { x => attr = scala.xml.Attribute(null, "VALEUR", x.toString, attr) }
      attr = scala.xml.Attribute(null, "POS", __obj.POS.toString, attr)
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.CARSET_CARType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultModelCARSETFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.CARSET] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.CARSET] =
      phrase(safeRep(scalaxb.ElemName(None, "CAR")) ^^
      { case p1 =>
      ch.bsisa.hyperbird.model.CARSET(p1 map { scalaxb.fromXML[ch.bsisa.hyperbird.model.CARSET_CARType](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.CARSET, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.CAR flatMap { scalaxb.toXML[ch.bsisa.hyperbird.model.CARSET_CARType](_, None, Some("CAR"), __scope, false) })

  }

  trait DefaultModelETATFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.ETAT] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.ETAT] =
      phrase(opt(scalaxb.ElemName(None, "ETAT1")) ~ 
      opt(scalaxb.ElemName(None, "ETAT2")) ~ 
      opt(scalaxb.ElemName(None, "ETAT3")) ~ 
      opt(scalaxb.ElemName(None, "ETAT4")) ~ 
      opt(scalaxb.ElemName(None, "ETAT5")) ~ 
      opt(scalaxb.ElemName(None, "ETAT6")) ~ 
      opt(scalaxb.ElemName(None, "ETAT7")) ~ 
      opt(scalaxb.ElemName(None, "ETAT8")) ~ 
      opt(scalaxb.ElemName(None, "ETAT9")) ~ 
      opt(scalaxb.ElemName(None, "ETAT10")) ~ 
      opt(scalaxb.ElemName(None, "ETAT11")) ~ 
      opt(scalaxb.ElemName(None, "ETAT12")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 =>
      ch.bsisa.hyperbird.model.ETAT(p1.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.STATEType](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.STATEType](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.STATEType](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.STATEType](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.STATEType](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.STATEType](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.STATEType](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.STATEType](_, scalaxb.ElemName(node) :: stack) },
        p9.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.STATEType](_, scalaxb.ElemName(node) :: stack) },
        p10.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.STATEType](_, scalaxb.ElemName(node) :: stack) },
        p11.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.STATEType](_, scalaxb.ElemName(node) :: stack) },
        p12.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.STATEType](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.ETAT, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.ETAT1 map { scalaxb.toXML[ch.bsisa.hyperbird.model.STATEType](_, None, Some("ETAT1"), __scope, false) } getOrElse {Nil},
        __obj.ETAT2 map { scalaxb.toXML[ch.bsisa.hyperbird.model.STATEType](_, None, Some("ETAT2"), __scope, false) } getOrElse {Nil},
        __obj.ETAT3 map { scalaxb.toXML[ch.bsisa.hyperbird.model.STATEType](_, None, Some("ETAT3"), __scope, false) } getOrElse {Nil},
        __obj.ETAT4 map { scalaxb.toXML[ch.bsisa.hyperbird.model.STATEType](_, None, Some("ETAT4"), __scope, false) } getOrElse {Nil},
        __obj.ETAT5 map { scalaxb.toXML[ch.bsisa.hyperbird.model.STATEType](_, None, Some("ETAT5"), __scope, false) } getOrElse {Nil},
        __obj.ETAT6 map { scalaxb.toXML[ch.bsisa.hyperbird.model.STATEType](_, None, Some("ETAT6"), __scope, false) } getOrElse {Nil},
        __obj.ETAT7 map { scalaxb.toXML[ch.bsisa.hyperbird.model.STATEType](_, None, Some("ETAT7"), __scope, false) } getOrElse {Nil},
        __obj.ETAT8 map { scalaxb.toXML[ch.bsisa.hyperbird.model.STATEType](_, None, Some("ETAT8"), __scope, false) } getOrElse {Nil},
        __obj.ETAT9 map { scalaxb.toXML[ch.bsisa.hyperbird.model.STATEType](_, None, Some("ETAT9"), __scope, false) } getOrElse {Nil},
        __obj.ETAT10 map { scalaxb.toXML[ch.bsisa.hyperbird.model.STATEType](_, None, Some("ETAT10"), __scope, false) } getOrElse {Nil},
        __obj.ETAT11 map { scalaxb.toXML[ch.bsisa.hyperbird.model.STATEType](_, None, Some("ETAT11"), __scope, false) } getOrElse {Nil},
        __obj.ETAT12 map { scalaxb.toXML[ch.bsisa.hyperbird.model.STATEType](_, None, Some("ETAT12"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultModelSTATETypeFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.STATEType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("STATEType")

    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.STATEType] =
      phrase(optTextRecord ^^
      { case p1 =>
      ch.bsisa.hyperbird.model.STATEType(Seq.concat(p1.toList),
        (node \ "@B").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@C").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.STATEType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.B foreach { x => attr = scala.xml.Attribute(null, "B", x.toString, attr) }
      __obj.C foreach { x => attr = scala.xml.Attribute(null, "C", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.STATEType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultModelCALCULTypeFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.CALCULType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("CALCULType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.CALCULType] =
      phrase(safeRep(scalaxb.ElemName(None, "L")) ~ 
      safeRep(scalaxb.ElemName(None, "DIMENSION")) ^^
      { case p1 ~ p2 =>
      ch.bsisa.hyperbird.model.CALCULType(p1 map { scalaxb.fromXML[ch.bsisa.hyperbird.model.L](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[ch.bsisa.hyperbird.model.DIMENSION](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.CALCULType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.L flatMap { scalaxb.toXML[ch.bsisa.hyperbird.model.L](_, None, Some("L"), __scope, false) },
        __obj.DIMENSION flatMap { scalaxb.toXML[ch.bsisa.hyperbird.model.DIMENSION](_, None, Some("DIMENSION"), __scope, false) })

  }

  def buildModelNOMFormat = new DefaultModelNOMFormat {}
  trait DefaultModelNOMFormat extends scalaxb.XMLFormat[ch.bsisa.hyperbird.model.NOM] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.NOM] = seq match {
      case elem: scala.xml.Elem => Right(ch.bsisa.hyperbird.model.NOM.fromString(elem.text, elem.scope))
      case _ => Right(ch.bsisa.hyperbird.model.NOM.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: ch.bsisa.hyperbird.model.NOM, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultModelDIMENSIONFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.DIMENSION] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.DIMENSION] =
      phrase(optTextRecord ^^
      { case p1 =>
      ch.bsisa.hyperbird.model.DIMENSION(Seq.concat(p1.toList),
        scalaxb.fromXML[ch.bsisa.hyperbird.model.NOM]((node \ "@NOM"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[ch.bsisa.hyperbird.model.TYPEType]((node \ "@TYPE"), scalaxb.ElemName(node) :: stack)) })
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.DIMENSION, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "NOM", __obj.NOM.toString, attr)
      attr = scala.xml.Attribute(null, "TYPE", __obj.TYPE.toString, attr)
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.DIMENSION, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultModelMATRICETypableFormat extends scalaxb.XMLFormat[ch.bsisa.hyperbird.model.MATRICETypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.MATRICETypable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (None, Some("CALCULType")) => Right(scalaxb.fromXML[ch.bsisa.hyperbird.model.CALCULType](node, stack))
          case _ => Right(scalaxb.fromXML[ch.bsisa.hyperbird.model.MATRICEType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: ch.bsisa.hyperbird.model.MATRICETypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: ch.bsisa.hyperbird.model.CALCULType => scalaxb.toXML[ch.bsisa.hyperbird.model.CALCULType](x, __namespace, __elementLabel, __scope, true)
      case x: ch.bsisa.hyperbird.model.MATRICEType => scalaxb.toXML[ch.bsisa.hyperbird.model.MATRICEType](x, __namespace, __elementLabel, __scope, false)
    }
  }

  trait DefaultModelMATRICETypeFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.MATRICEType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("MATRICEType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.MATRICEType] =
      phrase(safeRep(scalaxb.ElemName(None, "L")) ^^
      { case p1 =>
      ch.bsisa.hyperbird.model.MATRICEType(p1 map { scalaxb.fromXML[ch.bsisa.hyperbird.model.L](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.MATRICEType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.L flatMap { scalaxb.toXML[ch.bsisa.hyperbird.model.L](_, None, Some("L"), __scope, false) })

  }

  trait DefaultModelLFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.L] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.L] =
      phrase(safeRep(scalaxb.ElemName(None, "C")) ^^
      { case p1 =>
      ch.bsisa.hyperbird.model.L(p1 map { scalaxb.fromXML[ch.bsisa.hyperbird.model.C](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[BigInt]((node \ "@POS"), scalaxb.ElemName(node) :: stack)) })
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.L, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "POS", __obj.POS.toString, attr)
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.L, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.C flatMap { scalaxb.toXML[ch.bsisa.hyperbird.model.C](_, None, Some("C"), __scope, false) })

  }

  trait DefaultModelCFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.C] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.C] =
      phrase(optTextRecord ^^
      { case p1 =>
      ch.bsisa.hyperbird.model.C(Seq.concat(p1.toList),
        scalaxb.fromXML[BigInt]((node \ "@POS"), scalaxb.ElemName(node) :: stack)) })
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.C, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "POS", __obj.POS.toString, attr)
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.C, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultModelPARTENAIREFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.PARTENAIRE] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.PARTENAIRE] =
      phrase(opt(scalaxb.ElemName(None, "GERANT")) ~ 
      opt(scalaxb.ElemName(None, "USAGER")) ~ 
      opt(scalaxb.ElemName(None, "FOURNISSEUR")) ~ 
      opt(scalaxb.ElemName(None, "PROPRIETAIRE")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ch.bsisa.hyperbird.model.PARTENAIRE(p1.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.PERSONNEType](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.PERSONNEType](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.PERSONNEType](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.PERSONNEType](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.PARTENAIRE, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.GERANT map { scalaxb.toXML[ch.bsisa.hyperbird.model.PERSONNEType](_, None, Some("GERANT"), __scope, false) } getOrElse {Nil},
        __obj.USAGER map { scalaxb.toXML[ch.bsisa.hyperbird.model.PERSONNEType](_, None, Some("USAGER"), __scope, false) } getOrElse {Nil},
        __obj.FOURNISSEUR map { scalaxb.toXML[ch.bsisa.hyperbird.model.PERSONNEType](_, None, Some("FOURNISSEUR"), __scope, false) } getOrElse {Nil},
        __obj.PROPRIETAIRE map { scalaxb.toXML[ch.bsisa.hyperbird.model.PERSONNEType](_, None, Some("PROPRIETAIRE"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultModelPERSONNETypeFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.PERSONNEType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("PERSONNEType")

    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.PERSONNEType] =
      phrase(optTextRecord ^^
      { case p1 =>
      ch.bsisa.hyperbird.model.PERSONNEType(Seq.concat(p1.toList),
        (node \ "@Id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@ID_G").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@NOM").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@GROUPE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.PERSONNEType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.Id foreach { x => attr = scala.xml.Attribute(null, "Id", x.toString, attr) }
      __obj.ID_G foreach { x => attr = scala.xml.Attribute(null, "ID_G", x.toString, attr) }
      __obj.NOM foreach { x => attr = scala.xml.Attribute(null, "NOM", x.toString, attr) }
      __obj.GROUPE foreach { x => attr = scala.xml.Attribute(null, "GROUPE", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.PERSONNEType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultModelACTIVITEFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.ACTIVITE] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.ACTIVITE] =
      phrase(opt(scalaxb.ElemName(None, "EVENEMENT")) ~ 
      opt(scalaxb.ElemName(None, "GESTION")) ^^
      { case p1 ~ p2 =>
      ch.bsisa.hyperbird.model.ACTIVITE(p1.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.EVENEMENT](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.MATRICETypable](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.ACTIVITE, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.EVENEMENT map { scalaxb.toXML[ch.bsisa.hyperbird.model.EVENEMENT](_, None, Some("EVENEMENT"), __scope, false) } getOrElse {Nil},
        __obj.GESTION map { scalaxb.toXML[ch.bsisa.hyperbird.model.MATRICETypable](_, None, Some("GESTION"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultModelEVENEMENTFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.EVENEMENT] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.EVENEMENT] =
      phrase(safeRep(scalaxb.ElemName(None, "ECHEANCE")) ^^
      { case p1 =>
      ch.bsisa.hyperbird.model.EVENEMENT(p1 map { scalaxb.fromXML[ch.bsisa.hyperbird.model.ECHEANCE](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.EVENEMENT, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.ECHEANCE flatMap { scalaxb.toXML[ch.bsisa.hyperbird.model.ECHEANCE](_, None, Some("ECHEANCE"), __scope, false) })

  }

  trait DefaultModelECHEANCEFormat extends scalaxb.XMLFormat[ch.bsisa.hyperbird.model.ECHEANCE] with scalaxb.CanWriteChildNodes[ch.bsisa.hyperbird.model.ECHEANCE] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.ECHEANCE] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.ECHEANCE(scalaxb.fromXML[String]((node \ "@DATE"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@ACTION"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@PAR_QUI"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@POUR_QUI"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@E_DATE"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@E_ACTION"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@E_PAR_QUI"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@E_POUR_QUI"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[ch.bsisa.hyperbird.model.E_STATUT]((node \ "@E_STATUT"), scalaxb.ElemName(node) :: stack),
        (node \ "@REMARQUE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.ECHEANCE, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "DATE", __obj.DATE.toString, attr)
      attr = scala.xml.Attribute(null, "ACTION", __obj.ACTION.toString, attr)
      attr = scala.xml.Attribute(null, "PAR_QUI", __obj.PAR_QUI.toString, attr)
      attr = scala.xml.Attribute(null, "POUR_QUI", __obj.POUR_QUI.toString, attr)
      attr = scala.xml.Attribute(null, "E_DATE", __obj.E_DATE.toString, attr)
      attr = scala.xml.Attribute(null, "E_ACTION", __obj.E_ACTION.toString, attr)
      attr = scala.xml.Attribute(null, "E_PAR_QUI", __obj.E_PAR_QUI.toString, attr)
      attr = scala.xml.Attribute(null, "E_POUR_QUI", __obj.E_POUR_QUI.toString, attr)
      attr = scala.xml.Attribute(null, "E_STATUT", __obj.E_STATUT.toString, attr)
      __obj.REMARQUE foreach { x => attr = scala.xml.Attribute(null, "REMARQUE", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.ECHEANCE, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  def buildModelE_STATUTFormat = new DefaultModelE_STATUTFormat {}
  trait DefaultModelE_STATUTFormat extends scalaxb.XMLFormat[ch.bsisa.hyperbird.model.E_STATUT] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.E_STATUT] = seq match {
      case elem: scala.xml.Elem => Right(ch.bsisa.hyperbird.model.E_STATUT.fromString(elem.text, elem.scope))
      case _ => Right(ch.bsisa.hyperbird.model.E_STATUT.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: ch.bsisa.hyperbird.model.E_STATUT, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultModelANNEXEFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.ANNEXE] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.ANNEXE] =
      phrase(safeRep(scalaxb.ElemName(None, "RENVOI")) ^^
      { case p1 =>
      ch.bsisa.hyperbird.model.ANNEXE(p1 map { scalaxb.fromXML[ch.bsisa.hyperbird.model.RENVOI](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.ANNEXE, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.RENVOI flatMap { scalaxb.toXML[ch.bsisa.hyperbird.model.RENVOI](_, None, Some("RENVOI"), __scope, false) })

  }

  trait DefaultModelRENVOIFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.RENVOI] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.RENVOI] =
      phrase(optTextRecord ^^
      { case p1 =>
      ch.bsisa.hyperbird.model.RENVOI(Seq.concat(p1.toList),
        scalaxb.fromXML[BigInt]((node \ "@POS"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[java.net.URI]((node \ "@LIEN"), scalaxb.ElemName(node) :: stack)) })
    
    override def writesAttribute(__obj: ch.bsisa.hyperbird.model.RENVOI, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "POS", __obj.POS.toString, attr)
      attr = scala.xml.Attribute(null, "LIEN", __obj.LIEN.toString, attr)
      attr
    }

    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.RENVOI, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultModelDIVERSFormat extends scalaxb.ElemNameParser[ch.bsisa.hyperbird.model.DIVERS] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ch.bsisa.hyperbird.model.DIVERS] =
      phrase(opt(scalaxb.ElemName(None, "REMARQUE")) ~ 
      opt(scalaxb.ElemName(None, "METHODE")) ^^
      { case p1 ~ p2 =>
      ch.bsisa.hyperbird.model.DIVERS(p1.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ch.bsisa.hyperbird.model.DIVERS, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.REMARQUE map { scalaxb.toXML[String](_, None, Some("REMARQUE"), __scope, false) } getOrElse {Nil},
        __obj.METHODE map { scalaxb.toXML[String](_, None, Some("METHODE"), __scope, false) } getOrElse {Nil})

  }

  def buildModelTYPETypeFormat = new DefaultModelTYPETypeFormat {}
  trait DefaultModelTYPETypeFormat extends scalaxb.XMLFormat[ch.bsisa.hyperbird.model.TYPEType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.TYPEType] = seq match {
      case elem: scala.xml.Elem => Right(ch.bsisa.hyperbird.model.TYPEType.fromString(elem.text, elem.scope))
      case _ => Right(ch.bsisa.hyperbird.model.TYPEType.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: ch.bsisa.hyperbird.model.TYPEType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultModelECHEANCEu46attributeGroupFormat extends scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.ECHEANCEu46attributeGroup] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.ECHEANCEu46attributeGroup] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.ECHEANCEu46attributeGroup(scalaxb.fromXML[String]((node \ "@DATE"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[String]((node \ "@ACTION"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[String]((node \ "@PAR_QUI"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[String]((node \ "@POUR_QUI"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[String]((node \ "@E_DATE"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[String]((node \ "@E_ACTION"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[String]((node \ "@E_PAR_QUI"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[String]((node \ "@E_POUR_QUI"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[ch.bsisa.hyperbird.model.E_STATUT]((node \ "@E_STATUT"), scalaxb.ElemName(node) :: stack),
      (node \ "@REMARQUE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: ch.bsisa.hyperbird.model.ECHEANCEu46attributeGroup, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "DATE", __obj.DATE.toString, attr)
    attr = scala.xml.Attribute(null, "ACTION", __obj.ACTION.toString, attr)
    attr = scala.xml.Attribute(null, "PAR_QUI", __obj.PAR_QUI.toString, attr)
    attr = scala.xml.Attribute(null, "POUR_QUI", __obj.POUR_QUI.toString, attr)
    attr = scala.xml.Attribute(null, "E_DATE", __obj.E_DATE.toString, attr)
    attr = scala.xml.Attribute(null, "E_ACTION", __obj.E_ACTION.toString, attr)
    attr = scala.xml.Attribute(null, "E_PAR_QUI", __obj.E_PAR_QUI.toString, attr)
    attr = scala.xml.Attribute(null, "E_POUR_QUI", __obj.E_POUR_QUI.toString, attr)
    attr = scala.xml.Attribute(null, "E_STATUT", __obj.E_STATUT.toString, attr)
    __obj.REMARQUE foreach { x => attr = scala.xml.Attribute(null, "REMARQUE", x.toString, attr) }
      attr
    }
  }

  trait DefaultModelSTATETypeu46attributeGroupFormat extends scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.STATETypeu46attributeGroup] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.STATETypeu46attributeGroup] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.STATETypeu46attributeGroup((node \ "@B").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@C").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: ch.bsisa.hyperbird.model.STATETypeu46attributeGroup, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.B foreach { x => attr = scala.xml.Attribute(null, "B", x.toString, attr) }
    __obj.C foreach { x => attr = scala.xml.Attribute(null, "C", x.toString, attr) }
      attr
    }
  }

  trait DefaultModelLIBELLEu46attributeGroupFormat extends scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.LIBELLEu46attributeGroup] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.LIBELLEu46attributeGroup] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.LIBELLEu46attributeGroup((node \ "@POS").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@TEXTE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@X").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0.0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@Y").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0.0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ALPHA").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@TAILLE").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ANGLE").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0.0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@REMARQUE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: ch.bsisa.hyperbird.model.LIBELLEu46attributeGroup, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.POS foreach { x => attr = scala.xml.Attribute(null, "POS", x.toString, attr) }
    __obj.TEXTE foreach { x => attr = scala.xml.Attribute(null, "TEXTE", x.toString, attr) }
    if (__obj.X.toString != "0.0") attr = scala.xml.Attribute(null, "X", __obj.X.toString, attr)
    if (__obj.Y.toString != "0.0") attr = scala.xml.Attribute(null, "Y", __obj.Y.toString, attr)
    __obj.ALPHA foreach { x => attr = scala.xml.Attribute(null, "ALPHA", x.toString, attr) }
    if (__obj.TAILLE.toString != "1.0") attr = scala.xml.Attribute(null, "TAILLE", __obj.TAILLE.toString, attr)
    if (__obj.ANGLE.toString != "0.0") attr = scala.xml.Attribute(null, "ANGLE", __obj.ANGLE.toString, attr)
    __obj.REMARQUE foreach { x => attr = scala.xml.Attribute(null, "REMARQUE", x.toString, attr) }
      attr
    }
  }

  trait DefaultModelLIGNEu46attributeGroupFormat extends scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.LIGNEu46attributeGroup] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.LIGNEu46attributeGroup] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.LIGNEu46attributeGroup(scalaxb.fromXML[BigInt]((node \ "@POS"), scalaxb.ElemName(node) :: stack),
      (node \ "@DIRECTION").headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.DIRECTION](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[ch.bsisa.hyperbird.model.DIRECTION](scala.xml.Text("AVAL"), scalaxb.ElemName(node) :: stack) },
      (node \ "@Id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@ID_G").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@CLASSE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@FONCTION").headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.FONCTIONType2](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@REMARQUE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: ch.bsisa.hyperbird.model.LIGNEu46attributeGroup, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "POS", __obj.POS.toString, attr)
    if (__obj.DIRECTION.toString != "AVAL") attr = scala.xml.Attribute(null, "DIRECTION", __obj.DIRECTION.toString, attr)
    __obj.Id foreach { x => attr = scala.xml.Attribute(null, "Id", x.toString, attr) }
    __obj.ID_G foreach { x => attr = scala.xml.Attribute(null, "ID_G", x.toString, attr) }
    __obj.CLASSE foreach { x => attr = scala.xml.Attribute(null, "CLASSE", x.toString, attr) }
    __obj.FONCTION foreach { x => attr = scala.xml.Attribute(null, "FONCTION", x.toString, attr) }
    __obj.REMARQUE foreach { x => attr = scala.xml.Attribute(null, "REMARQUE", x.toString, attr) }
      attr
    }
  }

  trait DefaultModelGUIDEu46attributeGroupFormat extends scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.GUIDEu46attributeGroup] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.GUIDEu46attributeGroup] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.GUIDEu46attributeGroup(scalaxb.fromXML[BigInt]((node \ "@POS"), scalaxb.ElemName(node) :: stack),
      (node \ "@KSI").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@KSI2").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ETA").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ALPHA").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@KSIS").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@KSIS2").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ETAS").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ALPHAS").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@Id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@ID_G").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@CLASSE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@REMARQUE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: ch.bsisa.hyperbird.model.GUIDEu46attributeGroup, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "POS", __obj.POS.toString, attr)
    if (__obj.KSI.toString != "0") attr = scala.xml.Attribute(null, "KSI", __obj.KSI.toString, attr)
    if (__obj.KSI2.toString != "0") attr = scala.xml.Attribute(null, "KSI2", __obj.KSI2.toString, attr)
    if (__obj.ETA.toString != "0") attr = scala.xml.Attribute(null, "ETA", __obj.ETA.toString, attr)
    __obj.ALPHA foreach { x => attr = scala.xml.Attribute(null, "ALPHA", x.toString, attr) }
    if (__obj.KSIS.toString != "0") attr = scala.xml.Attribute(null, "KSIS", __obj.KSIS.toString, attr)
    if (__obj.KSIS2.toString != "0") attr = scala.xml.Attribute(null, "KSIS2", __obj.KSIS2.toString, attr)
    if (__obj.ETAS.toString != "0") attr = scala.xml.Attribute(null, "ETAS", __obj.ETAS.toString, attr)
    __obj.ALPHAS foreach { x => attr = scala.xml.Attribute(null, "ALPHAS", x.toString, attr) }
    __obj.Id foreach { x => attr = scala.xml.Attribute(null, "Id", x.toString, attr) }
    __obj.ID_G foreach { x => attr = scala.xml.Attribute(null, "ID_G", x.toString, attr) }
    __obj.CLASSE foreach { x => attr = scala.xml.Attribute(null, "CLASSE", x.toString, attr) }
    __obj.REMARQUE foreach { x => attr = scala.xml.Attribute(null, "REMARQUE", x.toString, attr) }
      attr
    }
  }

  trait DefaultModelPOINTu46attributeGroupFormat extends scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.POINTu46attributeGroup] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.POINTu46attributeGroup] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.POINTu46attributeGroup(scalaxb.fromXML[BigInt]((node \ "@POS"), scalaxb.ElemName(node) :: stack),
      (node \ "@X").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@Y").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@Z").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@XG").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@YG").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@ZG").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@KSI").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ANGLE").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ALPHA").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[String](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@XS").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@YS").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@ZS").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@KSIS").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ANGLES").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ALPHAS").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[String](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@Id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@ID_G").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      scalaxb.fromXML[ch.bsisa.hyperbird.model.FONCTION]((node \ "@FONCTION"), scalaxb.ElemName(node) :: stack),
      (node \ "@CLASSE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@GROUPE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: ch.bsisa.hyperbird.model.POINTu46attributeGroup, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "POS", __obj.POS.toString, attr)
    __obj.X foreach { x => attr = scala.xml.Attribute(null, "X", x.toString, attr) }
    __obj.Y foreach { x => attr = scala.xml.Attribute(null, "Y", x.toString, attr) }
    if (__obj.Z.toString != "0") attr = scala.xml.Attribute(null, "Z", __obj.Z.toString, attr)
    __obj.XG foreach { x => attr = scala.xml.Attribute(null, "XG", x.toString, attr) }
    __obj.YG foreach { x => attr = scala.xml.Attribute(null, "YG", x.toString, attr) }
    __obj.ZG foreach { x => attr = scala.xml.Attribute(null, "ZG", x.toString, attr) }
    if (__obj.KSI.toString != "0") attr = scala.xml.Attribute(null, "KSI", __obj.KSI.toString, attr)
    if (__obj.ANGLE.toString != "0") attr = scala.xml.Attribute(null, "ANGLE", __obj.ANGLE.toString, attr)
    if (__obj.ALPHA.toString != "0") attr = scala.xml.Attribute(null, "ALPHA", __obj.ALPHA.toString, attr)
    __obj.XS foreach { x => attr = scala.xml.Attribute(null, "XS", x.toString, attr) }
    __obj.YS foreach { x => attr = scala.xml.Attribute(null, "YS", x.toString, attr) }
    if (__obj.ZS.toString != "0") attr = scala.xml.Attribute(null, "ZS", __obj.ZS.toString, attr)
    if (__obj.KSIS.toString != "0") attr = scala.xml.Attribute(null, "KSIS", __obj.KSIS.toString, attr)
    if (__obj.ANGLES.toString != "0") attr = scala.xml.Attribute(null, "ANGLES", __obj.ANGLES.toString, attr)
    if (__obj.ALPHAS.toString != "0") attr = scala.xml.Attribute(null, "ALPHAS", __obj.ALPHAS.toString, attr)
    __obj.Id foreach { x => attr = scala.xml.Attribute(null, "Id", x.toString, attr) }
    __obj.ID_G foreach { x => attr = scala.xml.Attribute(null, "ID_G", x.toString, attr) }
    attr = scala.xml.Attribute(null, "FONCTION", __obj.FONCTION.toString, attr)
    __obj.CLASSE foreach { x => attr = scala.xml.Attribute(null, "CLASSE", x.toString, attr) }
    __obj.GROUPE foreach { x => attr = scala.xml.Attribute(null, "GROUPE", x.toString, attr) }
      attr
    }
  }

  trait DefaultModelMUTATIONu46attributeGroupFormat extends scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.MUTATIONu46attributeGroup] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.MUTATIONu46attributeGroup] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.MUTATIONu46attributeGroup(scalaxb.fromXML[String]((node \ "@DATE"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[String]((node \ "@ROLE"), scalaxb.ElemName(node) :: stack),
      (node \ "@MOT_DE_PASSE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@UTILISATEUR").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: ch.bsisa.hyperbird.model.MUTATIONu46attributeGroup, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "DATE", __obj.DATE.toString, attr)
    attr = scala.xml.Attribute(null, "ROLE", __obj.ROLE.toString, attr)
    __obj.MOT_DE_PASSE foreach { x => attr = scala.xml.Attribute(null, "MOT_DE_PASSE", x.toString, attr) }
    __obj.UTILISATEUR foreach { x => attr = scala.xml.Attribute(null, "UTILISATEUR", x.toString, attr) }
      attr
    }
  }

  trait DefaultModelELFINu46attributeGroupFormat extends scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.ELFINu46attributeGroup] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.ELFINu46attributeGroup] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.ELFINu46attributeGroup(scalaxb.fromXML[String]((node \ "@Id"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[String]((node \ "@ID_G"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[String]((node \ "@CLASSE"), scalaxb.ElemName(node) :: stack),
      (node \ "@GROUPE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@TYPE").headOption map { scalaxb.fromXML[ch.bsisa.hyperbird.model.TYPE](_, scalaxb.ElemName(node) :: stack) },
      scalaxb.fromXML[String]((node \ "@NATURE"), scalaxb.ElemName(node) :: stack),
      (node \ "@SOURCE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: ch.bsisa.hyperbird.model.ELFINu46attributeGroup, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "Id", __obj.Id.toString, attr)
    attr = scala.xml.Attribute(null, "ID_G", __obj.ID_G.toString, attr)
    attr = scala.xml.Attribute(null, "CLASSE", __obj.CLASSE.toString, attr)
    __obj.GROUPE foreach { x => attr = scala.xml.Attribute(null, "GROUPE", x.toString, attr) }
    __obj.TYPE foreach { x => attr = scala.xml.Attribute(null, "TYPE", x.toString, attr) }
    attr = scala.xml.Attribute(null, "NATURE", __obj.NATURE.toString, attr)
    __obj.SOURCE foreach { x => attr = scala.xml.Attribute(null, "SOURCE", x.toString, attr) }
      attr
    }
  }

  trait DefaultModelCENTROIDEu46attributeGroupFormat extends scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.CENTROIDEu46attributeGroup] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.CENTROIDEu46attributeGroup] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.CENTROIDEu46attributeGroup(scalaxb.fromXML[ch.bsisa.hyperbird.model.TYPEType]((node \ "@TYPE"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[Double]((node \ "@XM"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[Double]((node \ "@YM"), scalaxb.ElemName(node) :: stack),
      (node \ "@ZM").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) },
      scalaxb.fromXML[Double]((node \ "@RM"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: ch.bsisa.hyperbird.model.CENTROIDEu46attributeGroup, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "TYPE", __obj.TYPE.toString, attr)
    attr = scala.xml.Attribute(null, "XM", __obj.XM.toString, attr)
    attr = scala.xml.Attribute(null, "YM", __obj.YM.toString, attr)
    __obj.ZM foreach { x => attr = scala.xml.Attribute(null, "ZM", x.toString, attr) }
    attr = scala.xml.Attribute(null, "RM", __obj.RM.toString, attr)
      attr
    }
  }

  trait DefaultModelPASSAGEu46attributeGroupFormat extends scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.PASSAGEu46attributeGroup] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.PASSAGEu46attributeGroup] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.PASSAGEu46attributeGroup((node \ "@POS").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@KSI").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ANGLE").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ALPHA").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@KSIS").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ANGLES").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ALPHAS").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@Id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@ID_G").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      scalaxb.fromXML[ch.bsisa.hyperbird.model.FONCTIONType]((node \ "@FONCTION"), scalaxb.ElemName(node) :: stack),
      (node \ "@CLASSE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@GROUPE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@REMARQUE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: ch.bsisa.hyperbird.model.PASSAGEu46attributeGroup, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.POS foreach { x => attr = scala.xml.Attribute(null, "POS", x.toString, attr) }
    if (__obj.KSI.toString != "0") attr = scala.xml.Attribute(null, "KSI", __obj.KSI.toString, attr)
    if (__obj.ANGLE.toString != "0") attr = scala.xml.Attribute(null, "ANGLE", __obj.ANGLE.toString, attr)
    __obj.ALPHA foreach { x => attr = scala.xml.Attribute(null, "ALPHA", x.toString, attr) }
    if (__obj.KSIS.toString != "0") attr = scala.xml.Attribute(null, "KSIS", __obj.KSIS.toString, attr)
    if (__obj.ANGLES.toString != "0") attr = scala.xml.Attribute(null, "ANGLES", __obj.ANGLES.toString, attr)
    __obj.ALPHAS foreach { x => attr = scala.xml.Attribute(null, "ALPHAS", x.toString, attr) }
    __obj.Id foreach { x => attr = scala.xml.Attribute(null, "Id", x.toString, attr) }
    __obj.ID_G foreach { x => attr = scala.xml.Attribute(null, "ID_G", x.toString, attr) }
    attr = scala.xml.Attribute(null, "FONCTION", __obj.FONCTION.toString, attr)
    __obj.CLASSE foreach { x => attr = scala.xml.Attribute(null, "CLASSE", x.toString, attr) }
    __obj.GROUPE foreach { x => attr = scala.xml.Attribute(null, "GROUPE", x.toString, attr) }
    __obj.REMARQUE foreach { x => attr = scala.xml.Attribute(null, "REMARQUE", x.toString, attr) }
      attr
    }
  }

  trait DefaultModelPIECEu46attributeGroupFormat extends scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.PIECEu46attributeGroup] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.PIECEu46attributeGroup] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.PIECEu46attributeGroup(scalaxb.fromXML[String]((node \ "@ALIAS"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[String]((node \ "@Id"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[String]((node \ "@ID_G"), scalaxb.ElemName(node) :: stack),
      (node \ "@SYMBOLE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      scalaxb.fromXML[Double]((node \ "@LONGUEUR_UTILE"), scalaxb.ElemName(node) :: stack),
      (node \ "@ANGLE").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0.0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ECHELLE_X").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ECHELLE_Y").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ECHELLE_Z").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: ch.bsisa.hyperbird.model.PIECEu46attributeGroup, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "ALIAS", __obj.ALIAS.toString, attr)
    attr = scala.xml.Attribute(null, "Id", __obj.Id.toString, attr)
    attr = scala.xml.Attribute(null, "ID_G", __obj.ID_G.toString, attr)
    __obj.SYMBOLE foreach { x => attr = scala.xml.Attribute(null, "SYMBOLE", x.toString, attr) }
    attr = scala.xml.Attribute(null, "LONGUEUR_UTILE", __obj.LONGUEUR_UTILE.toString, attr)
    if (__obj.ANGLE.toString != "0.0") attr = scala.xml.Attribute(null, "ANGLE", __obj.ANGLE.toString, attr)
    if (__obj.ECHELLE_X.toString != "1.0") attr = scala.xml.Attribute(null, "ECHELLE_X", __obj.ECHELLE_X.toString, attr)
    if (__obj.ECHELLE_Y.toString != "1.0") attr = scala.xml.Attribute(null, "ECHELLE_Y", __obj.ECHELLE_Y.toString, attr)
    if (__obj.ECHELLE_Z.toString != "1.0") attr = scala.xml.Attribute(null, "ECHELLE_Z", __obj.ECHELLE_Z.toString, attr)
      attr
    }
  }

  trait DefaultModelSYMBOLEu46attributeGroupFormat extends scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.SYMBOLEu46attributeGroup] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.SYMBOLEu46attributeGroup] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.SYMBOLEu46attributeGroup(scalaxb.fromXML[BigInt]((node \ "@POS"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[String]((node \ "@NOM"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[String]((node \ "@CONTEXTE"), scalaxb.ElemName(node) :: stack),
      (node \ "@X").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0.0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@Y").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0.0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ALPHA").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@ANGLE").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("0.0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ECHELLE_X").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ECHELLE_Y").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@ECHELLE_Z").headOption map { scalaxb.fromXML[Double](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Double](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack) },
      (node \ "@REMARQUE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: ch.bsisa.hyperbird.model.SYMBOLEu46attributeGroup, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "POS", __obj.POS.toString, attr)
    attr = scala.xml.Attribute(null, "NOM", __obj.NOM.toString, attr)
    attr = scala.xml.Attribute(null, "CONTEXTE", __obj.CONTEXTE.toString, attr)
    if (__obj.X.toString != "0.0") attr = scala.xml.Attribute(null, "X", __obj.X.toString, attr)
    if (__obj.Y.toString != "0.0") attr = scala.xml.Attribute(null, "Y", __obj.Y.toString, attr)
    __obj.ALPHA foreach { x => attr = scala.xml.Attribute(null, "ALPHA", x.toString, attr) }
    if (__obj.ANGLE.toString != "0.0") attr = scala.xml.Attribute(null, "ANGLE", __obj.ANGLE.toString, attr)
    if (__obj.ECHELLE_X.toString != "1.0") attr = scala.xml.Attribute(null, "ECHELLE_X", __obj.ECHELLE_X.toString, attr)
    if (__obj.ECHELLE_Y.toString != "1.0") attr = scala.xml.Attribute(null, "ECHELLE_Y", __obj.ECHELLE_Y.toString, attr)
    if (__obj.ECHELLE_Z.toString != "1.0") attr = scala.xml.Attribute(null, "ECHELLE_Z", __obj.ECHELLE_Z.toString, attr)
    __obj.REMARQUE foreach { x => attr = scala.xml.Attribute(null, "REMARQUE", x.toString, attr) }
      attr
    }
  }

  trait DefaultModelCARTypeu46attributeGroupFormat extends scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.CARTypeu46attributeGroup] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.CARTypeu46attributeGroup] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.CARTypeu46attributeGroup((node \ "@NOM").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@UNITE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@VALEUR").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: ch.bsisa.hyperbird.model.CARTypeu46attributeGroup, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.NOM foreach { x => attr = scala.xml.Attribute(null, "NOM", x.toString, attr) }
    __obj.UNITE foreach { x => attr = scala.xml.Attribute(null, "UNITE", x.toString, attr) }
    __obj.VALEUR foreach { x => attr = scala.xml.Attribute(null, "VALEUR", x.toString, attr) }
      attr
    }
  }

  trait DefaultModelPERSONNETypeu46attributeGroupFormat extends scalaxb.AttributeGroupFormat[ch.bsisa.hyperbird.model.PERSONNETypeu46attributeGroup] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ch.bsisa.hyperbird.model.PERSONNETypeu46attributeGroup] = seq match {
      case node: scala.xml.Node => Right(ch.bsisa.hyperbird.model.PERSONNETypeu46attributeGroup((node \ "@Id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@ID_G").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@NOM").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@GROUPE").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: ch.bsisa.hyperbird.model.PERSONNETypeu46attributeGroup, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.Id foreach { x => attr = scala.xml.Attribute(null, "Id", x.toString, attr) }
    __obj.ID_G foreach { x => attr = scala.xml.Attribute(null, "ID_G", x.toString, attr) }
    __obj.NOM foreach { x => attr = scala.xml.Attribute(null, "NOM", x.toString, attr) }
    __obj.GROUPE foreach { x => attr = scala.xml.Attribute(null, "GROUPE", x.toString, attr) }
      attr
    }
  }


}

